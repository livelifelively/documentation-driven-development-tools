# P6: Documentation Content Validation System

## 1 Meta & Governance

### 1.2 Status

- **Created:** 2025-08-03 06:08
- **Last Updated:** 2025-08-03 06:08

### 1.3 Priority Drivers

- [TEC-Prod_Stability_Blocker](../ddd-2.md#tec-prod_stability_blocker)
- [TEC-Dev_Productivity_Enhancement](../ddd-2.md#tec-dev_productivity_enhancement)

---

## 2 Business & Scope

### 2.1 Overview

- **Core Function**: Provides a validation engine to ensure the _content_ of `*.plan.md` and `*.task.md` files conforms to the canonical schema.
- **Key Capability**: This system introduces a second tier of validation that operates on the final markdown documents. It uses a dedicated set of Zod schemas to validate the structure of the content within each documentation section.
- **Business Value**: Enforces runtime correctness and consistency of all documentation, ensuring that generated and manually edited documents adhere to the defined structure. This is critical for reliable parsing by automated tools and LLMs.

### 2.2 Business Context

Our currently implemented schema definition system generates documentation that specifies the rules for our markdown files. However, it lacks an enforcement mechanism. This plan fills that gap by creating a library of Zod schemas for content validation, ensuring that manually edited documents adhere to the required structure for reliable parsing by automated tools.

### 2.2.3 Core Business Rules

- **Focus on Content Rules**: This system's sole responsibility is to define the validation rules for the _content_ within markdown documentation files. It does not validate the schema definition files themselves.
- **Zod as the Rule Definition Language**: The expected structure for the content of each documentation section will be defined using Zod schemas.
- **Zod as the Source of Truth for Structure**: The Zod schemas produced by this system are the canonical source of truth for the _content structure_ of all documentation sections.
- **Schema Independence**: The validation rules created here must be self-contained and not directly dependent on the file structure of the schema definition system. They represent the abstract rules, not the implementation of the schema storage.

### 2.3 Success Criteria

- A comprehensive library of Zod schemas is created, covering the content structure for all sections defined in the canonical documentation schema.
- Each Zod schema correctly and strictly enforces the documented rules for its corresponding section (e.g., required fields, data types, table structures).
- The created schemas can be successfully imported and used by a consumer to validate compliant and non-compliant content.
- The schema library is organized logically, making it easy to maintain and extend as the documentation methodology evolves.

### 2.5 Boundaries & Scope

#### 2.5.1 In Scope

- Defining and maintaining a comprehensive library of Zod schemas that represent the content rules for every section in the documentation.
- Providing clear, typed exports for all schemas so they can be consumed by other systems.
- Ensuring the schema library is well-organized and maintainable.

#### 2.5.2 Out of Scope

- The implementation of any tool that consumes these schemas, such as a markdown parser or linter.
- The validation of the `*.json` schema _definition_ files.
- Auto-correction of invalid markdown content.
- Real-time validation in an IDE or git-hooks (these are consumers of the schemas, not part of their definition).

---

## 3 Planning & Decomposition

### 3.1 Roadmap (In-Focus Items)

| ID  | Child Plan/Task                                                                         | Priority  | Priority Drivers                                                                 | Status         | Depends On | Summary                                                                               |
| :-- | :-------------------------------------------------------------------------------------- | :-------- | :------------------------------------------------------------------------------- | :------------- | :--------- | :------------------------------------------------------------------------------------ |
| T32 | [Define Section Content Schemas](./p1-p6.t32-define-section-content-schemas.task.md)    | ðŸŸ¥ High   | [TEC-Prod_Stability_Blocker](../ddd-2.md#tec-prod_stability_blocker)             | âœ… Complete    | T28        | Create the Zod schemas that define the expected content for each section.             |
| T33 | [Statically Generate Composed Schemas](./p1-p6.t33-statically-generate-schemas.task.md) | ðŸŸ§ Medium | [TEC-Dev_Productivity_Enhancement](../ddd-2.md#tec-dev_productivity_enhancement) | ðŸ’¡ Not Started | T32        | Implement a build-time process to statically generate schemas for better performance. |
| T34 | [Schema Provider Implementation](./p1-p6.t34-schema-provider.task.md)                   | ðŸŸ¥ High   | [TEC-Prod_Stability_Blocker](../ddd-2.md#tec-prod_stability_blocker)             | ðŸ’¡ Not Started | T32        | Implement provider that composes schemas and returns standardized ValidationResult.   |

### 3.3 Dependencies

| ID  | Dependency On                                                       | Type     | Status         | Affected Plans/Tasks | Notes                                                                                            |
| :-- | :------------------------------------------------------------------ | :------- | :------------- | :------------------- | :----------------------------------------------------------------------------------------------- |
| D-1 | [Canonical Schema Interfaces](./p1.t28-define-schema-types.task.md) | Internal | ðŸ’¡ Not Started | T32                  | The base types for the schema definition itself are a prerequisite for creating content schemas. |

### 3.4 Decomposition Graph

```mermaid
graph TD
    subgraph "P6: Doc Content Validator"
        T32["T32: Define Section Content Schemas"]
        T33["T33: Statically Generate Composed Schemas"]
    end

    T32 --> T33
```

### 3.5 Downstream Consumers

This plan produces a library of validation schemas. The primary consumer of this library is the **Documentation Parser & Linter** system, which will import these schemas to perform linting and validation on markdown content.

Additionally, this plan will expose a `SchemaProvider` implementation that the parser can inject. It composes per-section Zod schemas into a document-type-aware validator and returns `VALIDATION_RESULT` payloads compatible with the parserâ€™s event contracts.

---

## 4 High-Level Design

### 4.0 Guiding Principles

- **Single Responsibility**: Each Zod schema is responsible for validating the content of exactly one documentation section.
- **Composability**: Complex schemas should be built by composing smaller, reusable schemas to avoid duplication.
- **Strictness**: Schemas should be as strict as possible, enforcing data types, required fields, and formats to guarantee content integrity.
- **Maintainability**: The schema library must be organized in a clear, logical structure that is easy for developers to navigate and extend.

### 4.2 Target Architecture

#### 4.2.1 Data Models

This model shows the complete data architecture of the Documentation Content Validation System, consolidating insights from all child tasks (T32, T33, T34). It represents the big picture of how schema definitions are composed and used to produce validation results, adhering to the principle of separating data from operational components.

```mermaid
erDiagram
    DOCUMENT_DATA{
        string docType "document type: plan | task"
    }

    FAMILY_SCHEMA_DEFINITION ||--|| FAMILY_ZOD_SCHEMA : "guides"
    FAMILY_SCHEMA_DEFINITION ||--|{ SECTION_ZOD_SCHEMA : "guides"
    FAMILY_SCHEMA_DEFINITION ||--|{ FIELD_ZOD_SCHEMA : "guides"

    FAMILY_ZOD_SCHEMA ||--|{ SECTION_ZOD_SCHEMA : "composes"
    SECTION_ZOD_SCHEMA ||--|{ FIELD_ZOD_SCHEMA : "composes"

    FAMILY_ZOD_SCHEMA ||--o{ PLAN_ZOD_SCHEMA : "composes into"
    FAMILY_ZOD_SCHEMA ||--o{ TASK_ZOD_SCHEMA : "composes into"

    PLAN_ZOD_SCHEMA ||--|| STATIC_SCHEMA : "can be persisted as"
    TASK_ZOD_SCHEMA ||--|| STATIC_SCHEMA : "can be persisted as"

    PLAN_ZOD_SCHEMA ||--|| DOCUMENT_DATA : "validates"
    TASK_ZOD_SCHEMA ||--|| DOCUMENT_DATA : "validates"

    PLAN_ZOD_SCHEMA ||--|| VALIDATION_RESULT : "produces"
    TASK_ZOD_SCHEMA ||--|| VALIDATION_RESULT : "produces"
    VALIDATION_RESULT ||--o{ LINTING_ERROR : "aggregates"
```

#### 4.2.2 Components

The primary component is the schema library. We also provide a `SchemaProvider` implementation to ease consumption by P5.

```mermaid
classDiagram
    direction LR

    %% T32 Components (Updated)
    class JsonDataSource_T32:::t32 {
        <<Data Source>>
        "ddd-schema-json/*.json"
    }
    class FamilySchemaModule_T32:::t32 {
        <<Decentralized Factory>>
        "[N]-family.schema.ts"
    }
    class IndexModule_T32:::t32 {
        <<Orchestrator>>
        "index.ts"
    }
    class ComposedSchema_T32:::t32 {
        <<Composed Output>>
        "PlanZodSchema / TaskZodSchema"
    }

    %% T33 Components (Unchanged)
    class BuildScript_T33:::t33 {
        <<Tool>>
    }
    class GeneratedSchemas_T33:::t33 {
        <<Static Asset>>
    }

    %% T34 Components (Unchanged)
    class SchemaProviderImpl_T34:::t34 {
        <<Service>>
    }

    %% External Consumer (Unchanged)
    class SchemaConsumer_External:::external {
        <<Consumer>>
    }

    %% Relationships
    JsonDataSource_T32 --|> FamilySchemaModule_T32 : "provides rules to"
    FamilySchemaModule_T32 --|> IndexModule_T32 : "is assembled by"
    IndexModule_T32 --> ComposedSchema_T32 : "produces"

    %% Inter-task Relationships
    ComposedSchema_T32 --|> BuildScript_T33 : "is used by"
    BuildScript_T33 --> GeneratedSchemas_T33 : "writes"
    ComposedSchema_T32 --|> SchemaProviderImpl_T34 : "is composed by"
    SchemaProviderImpl_T34 --|> SchemaConsumer_External : "is used by"
    GeneratedSchemas_T33 --|> SchemaConsumer_External : "is imported by"

    %% Define styles for each task
    classDef t32 fill:#cde4ff,stroke:#369,stroke-width:2px,color:#000;
    classDef t33 fill:#d5e8d4,stroke:#82b366,stroke-width:2px,color:#000;
    classDef t34 fill:#ffe6cc,stroke:#d79b00,stroke-width:2px,color:#000;
    classDef external fill:#f8cecc,stroke:#b85450,stroke-width:2px,color:#000;
```

#### 4.2.3 Data Flow

This diagram shows the end-to-end data flow, incorporating the schema creation process from T32 and its consumption by the provider from T34.

```mermaid
graph TD
    subgraph "T32: Schema Creation"
        A["JsonDataSource"] -- "1: FAMILY_SCHEMA_DEFINITION" --> B("FamilySchemaModule");
        B -- "2: FAMILY_ZOD_SCHEMA" --> C("IndexModule");
        C -- "3: PLAN_ZOD_SCHEMA / TASK_ZOD_SCHEMA" --> D(Document Zod Schemas);
    end

    subgraph "T34: Validation"
        E["Consumer"] -- "4: DOCUMENT_DATA" --> F(SchemaProviderImpl);
        D -- "5: SCHEMA" --> F;
        F -- "6: VALIDATION_RESULT" --> G["Output"];
    end
```

#### 4.2.4 Control Flow

This sequence shows how a consumer interacts with the `SchemaProvider` (T34), which in turn orchestrates the schema composition using the factory functions from T32.

```mermaid
sequenceDiagram
    participant Consumer
    participant SchemaProviderImpl as T34: SchemaProvider
    participant IndexModule as T32: IndexModule
    participant FamilySchemaModule as T32: FamilySchemaModule

    Consumer->>+SchemaProviderImpl: validate(document)
    SchemaProviderImpl->>+IndexModule: createSchema(document.docType)
    IndexModule->>+FamilySchemaModule: createFamilySchema(docType)
    FamilySchemaModule-->>-IndexModule: familyZodSchema
    IndexModule-->>-SchemaProviderImpl: composedSchema
    SchemaProviderImpl->>SchemaProviderImpl: performValidation(document, composedSchema)
    SchemaProviderImpl-->>-Consumer: validationResult
```

### 4.3 Tech Stack & Deployment

- **Language**: TypeScript
- **Schema Validation**: Zod
- **Testing**: Vitest
- **Deployment**: The schema library will be an internal module of the `ddd-tools` npm package, exposed for use by other modules within the same package.

### 4.4 Non-Functional Requirements

#### 4.4.1 Performance

| ID      | Requirement                                                                  | Priority  |
| :------ | :--------------------------------------------------------------------------- | :-------- |
| PERF-01 | Schema compilation and type inference should add negligible time to TSC.     | ðŸŸ¥ High   |
| PERF-02 | Importing the schemas should have a minimal impact on consumer startup.      | ðŸŸ§ Medium |
| PERF-03 | Provider validation must process a typical documentâ€™s `Section[]` in < 50ms. | ðŸŸ§ Medium |

#### 4.4.2 Reliability

| ID     | Requirement                                                            | Priority |
| :----- | :--------------------------------------------------------------------- | :------- |
| REL-01 | Schemas must be 100% aligned with the official documentation rules.    | ðŸŸ¥ High  |
| REL-02 | A schema change must not break consumers without a major version bump. | ðŸŸ¥ High  |

#### 4.4.3 Scalability

| ID      | Requirement                                                           | Priority |
| :------ | :-------------------------------------------------------------------- | :------- |
| SCAL-01 | The library structure must support adding new section schemas easily. | ðŸŸ¥ High  |

---

## 5 Maintenance and Monitoring

### 5.2 Target Maintenance and Monitoring

#### 5.2.1 Error Handling

| Error Type                     | Trigger                                                                  | Action                                       | User Feedback                                                                                 |
| :----------------------------- | :----------------------------------------------------------------------- | :------------------------------------------- | :-------------------------------------------------------------------------------------------- |
| **Schema Validation Failure**  | A consumer calls `schema.parse()` with a non-compliant content object.   | Zod throws a `ZodError`.                     | The `ZodError` object contains detailed information about the validation failure.             |
| **Schema Import Failure**      | A consumer attempts to import a non-existent schema from the library.    | Runtime throws an error.                     | Standard module-not-found error from the runtime environment (e.g., Node.js, bundler).        |
| **Document-Type Rule Miss**    | Provider asked to compose a docType that lacks required section schemas. | Provider throws or returns failed result.    | Clear message listing the missing section schemas for the requested docType.                  |
| **Provider Contract Mismatch** | Provider returns a payload that is not a `VALIDATION_RESULT`.            | Consumer rejects and logs contract mismatch. | Ensure provider outputs follow the `ValidationResult` contract expected by the parser events. |

#### 5.2.2 Logging & Monitoring

- **Logging**: Not applicable. As a static library, this system does not perform logging.
- **Monitoring**: Not applicable.

---

## 6 Implementation Guidance

### 6.1 Implementation Plan

The implementation of this schema library will be carried out in the child task, **[T32: Define Section Content Schemas](./p1-p6.t32-define-section-content-schemas.task.md)**. The strategy is as follows:

1.  **Establish Directory Structure**: Create the folder structure for the schemas, organized by documentation family (e.g., `src/validation-schemas/1-meta-governance/`).
2.  **Develop Schemas Incrementally**: Implement the Zod schemas for each documentation section one by one.
3.  **Unit Test Each Schema**: For each section schema, create a corresponding unit test that validates both compliant and non-compliant example content.
4.  **Create Barrel File**: Create a main entry point (`index.ts`) that exports all section schemas for easy consumption by other tools.
5.  **Provide Provider**: Export a `createSchemaProvider()` that returns a `SchemaProvider` implementation composing the section schemas per document type.

---

## 7 Quality & Operations

### 7.1 Testing Strategy / Requirements

The quality of this library is determined by the correctness and coverage of its schemas. The testing strategy is therefore focused on rigorous unit testing of each individual schema, with test cases mapped to the plan's Success Criteria.

| AC   | Scenario                                                              | Test Type | Tools / Runner | Notes                                                                                     |
| :--- | :-------------------------------------------------------------------- | :-------- | :------------- | :---------------------------------------------------------------------------------------- |
| SC-3 | A schema successfully parses a valid, compliant content object.       | Unit      | Vitest         | For each schema, provide a "golden path" test case with a perfect example of the content. |
| SC-3 | A schema fails to parse an object with missing required fields.       | Unit      | Vitest         | Test that `schema.parse()` throws a `ZodError` and that the error message is informative. |
| SC-3 | A schema fails to parse an object with fields of the incorrect type.  | Unit      | Vitest         | E.g., provide a string where a number is expected and assert that it throws.              |
| SC-2 | A schema fails to parse an object that violates a custom `.refine()`. | Unit      | Vitest         | For any schemas with custom validation rules, ensure those rules are explicitly tested.   |

### 7.2 Configuration

This system is a library and requires no runtime configuration.

### 7.3 Alerting & Response

Not applicable. Error handling is the responsibility of the consumer.

### 7.4 Deployment Steps

Deployment of this library is handled as part of the parent `ddd-tools` npm package. There are no separate deployment steps for this specific module.

---

## 8 Reference

### 8.1 Appendices/Glossary

#### Two-Tier Validation System

Our documentation ecosystem uses a two-tier validation approach to ensure correctness at all levels:

**Tier 1: The Documentation Schema & Rule Validation System**

- **What it is:** This is the foundational layer responsible for the **rules of Documentation-Driven Development**. It encompasses both the rules themselves (as defined in `ddd-2.md` and codified in the `src/schema/ddd-schema-json/` files) and the system that ensures those rules are valid, consistent, and correctly structured.
- **What it does:** A dedicated script (`validate-family-schemas.ts`) validates the JSON definition files to confirm the integrity of the rulebook itself. It answers the question: "Is our system of rules for documentation valid and well-formed?"
- **Scope:** This system is defined in Plan P1 and is a prerequisite for the second tier.

**Tier 2: Markdown Content Validation (The focus of this Plan)**

- **What it is:** This is the application layer that validates the final `*.plan.md` and `*.task.md` markdown files that developers write.
- **What it does:** It uses the Zod schemas created by this plan (P6) to check if the markdown content complies with the rules established and validated by Tier 1. It answers the question: "Does this specific document correctly follow our established rules?"
- **Scope:** This is the sole responsibility of the **Documentation Content Validation System** defined in this plan (P6).
